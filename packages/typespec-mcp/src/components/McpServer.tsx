import { Program } from "@typespec/compiler";
import { code, mapJoin } from "@alloy-js/core";
import * as ts from "@alloy-js/typescript";

// Add JSX namespace reference
import { JSX } from "@alloy-js/core";

// The important things to build in this file are:
// 1. All of the boilerplate code for the MCP server project (package.json, Dockerfile, etc.)
// 2. The actual code for the MCP server itself into index.ts.

export interface McpServerOptions {
  // Using a simpler structure for operations
  operations: Array<{
    operationId: string;
    path: string;
    method: string;
    description?: string;
  }>;
  program: Program;
}

export interface McpServerOutput {
  path: string;
  content: JSX.Element;
}

/**
 * Generates all files for an MCP server project
 * @param options Server generation options
 * @returns Array of file contents with their paths
 */
export function generateMcpServerProject(options: McpServerOptions): McpServerOutput[] {
  const { operations, program } = options;
  
  // Generate the various files for the MCP server project
  return [
    {
      path: "package.json",
      content: <PackageJson />
    },
    {
      path: "tsconfig.json",
      content: <TsConfig />
    },
    {
      path: "Dockerfile",
      content: <Dockerfile />
    },
    {
      path: "README.md",
      content: <ReadmeFile />
    },
    {
      path: "src/index.ts",
      content: <IndexTs operations={operations} program={program} />
    }
  ];
}

function PackageJson() {
  return code`
    {
      "name": "mcp-server",
      "version": "1.0.0",
      "description": "MCP Server implementation",
      "main": "dist/index.js",
      "type": "module",
      "scripts": {
        "build": "tsc",
        "start": "node dist/index.js",
        "dev": "ts-node --esm src/index.ts"
      },
      "dependencies": {
        "express": "^4.18.2",
        "body-parser": "^1.20.2",
        "cors": "^2.8.5",
        "@modelcontextprotocol/sdk": "^0.1.0",
        "zod": "^3.22.4",
        "zod-to-json-schema": "^3.22.3"
      },
      "devDependencies": {
        "typescript": "^5.0.4",
        "ts-node": "^10.9.1",
        "@types/express": "^4.17.17",
        "@types/cors": "^2.8.13"
      }
    }
  `;
}

function TsConfig() {
  return code`
    {
      "compilerOptions": {
        "target": "ES2020",
        "module": "NodeNext",
        "moduleResolution": "NodeNext",
        "outDir": "./dist",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
      },
      "include": ["src/**/*"],
      "exclude": ["node_modules"]
    }
  `;
}

function Dockerfile() {
  return code`
    FROM node:18-alpine

    WORKDIR /app

    COPY package*.json ./

    RUN npm install --only=production

    COPY dist/ ./dist/

    EXPOSE 3000

    CMD ["node", "dist/index.js"]
  `;
}

function ReadmeFile() {
  return code`
    # MCP Server

    This is an automatically generated Model Context Protocol server based on your TypeSpec API definition.

    ## Getting Started

    1. Install dependencies:
       \`\`\`
       npm install
       \`\`\`

    2. Build the server:
       \`\`\`
       npm run build
       \`\`\`

    3. Start the server:
       \`\`\`
       npm start
       \`\`\`

    ## Development

    For development with hot reload:
    \`\`\`
    npm run dev
    \`\`\`

    ## Docker

    To build and run with Docker:
    \`\`\`
    docker build -t mcp-server .
    docker run -p 3000:3000 mcp-server
    \`\`\`
  `;
}

interface IndexTsProps {
  operations: McpServerOptions['operations'];
  program: Program;
}

function IndexTs({ operations, program }: IndexTsProps) {
  return code`
    #!/usr/bin/env node
    import { Server } from "@modelcontextprotocol/sdk/server/index.js";
    import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
    import {
      CallToolRequestSchema,
      ListToolsRequestSchema,
    } from "@modelcontextprotocol/sdk/types.js";
    import { z } from 'zod';
    import { zodToJsonSchema } from 'zod-to-json-schema';
    import express from 'express';

    // Import schemas generated by typespec-mcp
    import * as schemas from './types.js';

    // Constants
    const VERSION = "1.0.0";

    // Create MCP server
    const server = new Server(
      {
        name: "typespec-mcp-server",
        version: VERSION,
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    // Setup Express for HTTP endpoints
    const app = express();
    const port = process.env.PORT || 3000;
    app.use(express.json());

    // Set up MCP request handlers
    server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          ${<ToolDefinitions operations={operations} />}
        ],
      };
    });

    server.setRequestHandler(CallToolRequestSchema, async (request) => {
      try {
        if (!request.params.arguments) {
          throw new Error("Arguments are required");
        }

        switch (request.params.name) {
          ${<ToolHandlers operations={operations} />}
          default:
            throw new Error(\`Unknown tool: \${request.params.name}\`);
        }
      } catch (error) {
        if (error instanceof z.ZodError) {
          throw new Error(\`Invalid input: \${JSON.stringify(error.errors)}\`);
        }
        throw error;
      }
    });

    // Set up HTTP endpoints
    ${<HttpEndpoints operations={operations} />}

    // Health check endpoint
    app.get('/api/health', (req, res) => {
      res.json({ status: 'ok' });
    });

    // MCP manifest endpoint
    app.get('/.well-known/mcp', (req, res) => {
      res.json({
        manifestVersion: "0.1",
        apis: [
          {
            name: "default",
            description: "Generated MCP API",
            specification: "/mcp/openapi.json"
          }
        ]
      });
    });

    // OpenAPI spec endpoint
    app.get('/mcp/openapi.json', (req, res) => {
      res.json({
        // This would be replaced with an actual OpenAPI spec
        // generated from your TypeSpec model
        openapi: "3.0.0",
        info: {
          title: "Generated MCP API",
          version: "1.0.0"
        },
        paths: {}
      });
    });

    // Start the HTTP server
    app.listen(port, () => {
      console.log(\`HTTP server running on port \${port}\`);
    });

    // Start the MCP server
    async function runServer() {
      const transport = new StdioServerTransport();
      await server.connect(transport);
      console.error("MCP Server running on stdio");
    }

    runServer().catch((error) => {
      console.error("Fatal error:", error);
      process.exit(1);
    });
  `;
}

interface ToolDefinitionsProps {
  operations: McpServerOptions['operations'];
}

function ToolDefinitions({ operations }: ToolDefinitionsProps) {
  if (!operations || operations.length === 0) {
    return code`
      {
        name: "example_operation",
        description: "Example operation for demonstration",
        inputSchema: zodToJsonSchema(schemas.ExampleModel)
      }
    `;
  }
  
  return mapJoin(
    operations,
    (op) => {
      const modelName = `${op.operationId}Model`;
      return code`
        {
          name: "${op.operationId}",
          description: "${op.description || `Operation for ${op.path}`}",
          inputSchema: zodToJsonSchema(schemas.${modelName})
        }
      `;
    },
    { joiner: ",\n" }
  );
}

interface ToolHandlersProps {
  operations: McpServerOptions['operations'];
}

function ToolHandlers({ operations }: ToolHandlersProps) {
  if (!operations || operations.length === 0) {
    return code`
      case "example_operation": {
        const args = schemas.ExampleModel.parse(request.params.arguments);
        // Implement operation logic here
        return {
          content: [{ type: "text", text: JSON.stringify({ 
            message: "Example operation executed", 
            args 
          }, null, 2) }]
        };
      }
    `;
  }
  
  return mapJoin(
    operations,
    (op) => {
      const modelName = `${op.operationId}Model`;
      return code`
        case "${op.operationId}": {
          const args = schemas.${modelName}.parse(request.params.arguments);
          // Implement operation logic here
          return {
            content: [{ type: "text", text: JSON.stringify({ 
              message: "${op.operationId} executed", 
              args 
            }, null, 2) }]
          };
        }
      `;
    },
    { joiner: "\n" }
  );
}

interface HttpEndpointsProps {
  operations: McpServerOptions['operations'];
}

function HttpEndpoints({ operations }: HttpEndpointsProps) {
  if (!operations || operations.length === 0) {
    return code`// No HTTP endpoints defined in the TypeSpec model`;
  }
  
  return mapJoin(
    operations,
    (op) => {
      const modelName = `${op.operationId}Model`;
      const method = op.method.toLowerCase();
      
      return code`
        app.${method}('${op.path}', (req, res) => {
          try {
            const args = schemas.${modelName}.parse(req.body);
            // Implement operation logic here
            res.json({ message: "${op.operationId} executed", args });
          } catch (error) {
            if (error instanceof z.ZodError) {
              res.status(400).json({ error: error.errors });
            } else {
              res.status(500).json({ error: error.message });
            }
          }
        });
      `;
    },
    { joiner: "\n\n" }
  );
}